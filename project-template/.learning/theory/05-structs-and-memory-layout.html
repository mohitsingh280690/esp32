<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structs and Memory Layout - ESP32 FreeRTOS Tutorial</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #667eea;
            border-bottom: 4px solid #667eea;
            padding-bottom: 15px;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        h2 {
            color: #764ba2;
            margin-top: 40px;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-left: 5px solid #764ba2;
            padding-left: 15px;
        }
        
        h3 {
            color: #667eea;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .concept-box {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            border-left: 5px solid #667eea;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
        }
        
        .warning-box {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
        }
        
        .success-box {
            background: #d4edda;
            border-left: 5px solid #28a745;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
        }
        
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', Consolas, Monaco, monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre;
        }
        
        .keyword { color: #ff79c6; font-weight: bold; }
        .type { color: #8be9fd; }
        .function { color: #50fa7b; }
        .comment { color: #6272a4; font-style: italic; }
        .string { color: #f1fa8c; }
        .number { color: #bd93f9; }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 25px 0;
        }
        
        .comparison > div {
            padding: 20px;
            border-radius: 8px;
        }
        
        .bad {
            background: #f8d7da;
            border: 2px solid #dc3545;
        }
        
        .good {
            background: #d4edda;
            border: 2px solid #28a745;
        }
        
        .memory-diagram {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 25px 0;
            border: 2px solid #dee2e6;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
        }
        
        th, td {
            border: 1px solid #dee2e6;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .question {
            background: #e7f3ff;
            border-left: 5px solid #2196F3;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
        }
        
        .answer {
            background: #f0f0f0;
            padding: 15px;
            margin-top: 10px;
            border-radius: 5px;
            font-style: italic;
        }
        
        ul, ol {
            margin: 15px 0;
            padding-left: 30px;
        }
        
        li {
            margin: 10px 0;
        }
        
        strong {
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üì¶ Structs and Memory Layout in Embedded C</h1>
        
        <div class="concept-box">
            <h3>üéØ What You'll Learn</h3>
            <ul>
                <li><strong>typedef struct</strong> - Creating clean, reusable data types</li>
                <li><strong>Memory padding and alignment</strong> - Why sizeof() surprises you</li>
                <li><strong>Struct initialization</strong> - C vs C++ differences</li>
                <li><strong>Queuing structs</strong> - Copying composite data safely</li>
                <li><strong>Format specifiers</strong> - Printing struct fields correctly</li>
            </ul>
        </div>

        <h2>üìö Why Structs in Embedded Systems?</h2>
        
        <div class="concept-box">
            <h3>The Problem: Related Data Scattered Everywhere</h3>
            <div class="code-block"><span class="comment">// ‚ùå BAD: Separate variables for related data</span>
<span class="type">uint32_t</span> timestamp;
<span class="type">uint8_t</span> sensor_id;
<span class="type">float</span> temperature;

<span class="comment">// How do you pass all three to a function?</span>
<span class="function">process_reading</span>(timestamp, sensor_id, temperature);  <span class="comment">// Messy!</span>
<span class="function">log_data</span>(timestamp, sensor_id, temperature);         <span class="comment">// Error-prone!</span></div>

            <h3>The Solution: Group Related Data</h3>
            <div class="code-block"><span class="comment">// ‚úÖ GOOD: Struct groups related data</span>
<span class="keyword">typedef struct</span> {
    <span class="type">uint32_t</span> timestamp;
    <span class="type">uint8_t</span> sensor_id;
    <span class="type">float</span> temperature;
} <span class="type">sensor_data_t</span>;

<span class="comment">// Now you can pass everything as one unit</span>
<span class="type">sensor_data_t</span> reading = {<span class="number">1234</span>, <span class="number">1</span>, <span class="number">23.5f</span>};
<span class="function">process_reading</span>(reading);  <span class="comment">// Clean!</span>
<span class="function">log_data</span>(reading);         <span class="comment">// Easy!</span></div>
        </div>

        <h2>üîß typedef struct - The Proper Way</h2>

        <div class="concept-box">
            <h3>Without typedef (Old C Style)</h3>
            <div class="code-block"><span class="keyword">struct</span> sensor_data {
    <span class="type">uint32_t</span> timestamp;
    <span class="type">uint8_t</span> sensor_id;
    <span class="type">float</span> temperature;
};

<span class="comment">// Declaration requires "struct" keyword every time</span>
<span class="keyword">struct</span> <span class="type">sensor_data</span> reading;  <span class="comment">// Verbose!</span></div>

            <h3>With typedef (Modern Embedded C)</h3>
            <div class="code-block"><span class="keyword">typedef struct</span> {
    <span class="type">uint32_t</span> timestamp;
    <span class="type">uint8_t</span> sensor_id;
    <span class="type">float</span> temperature;
} <span class="type">sensor_data_t</span>;
    <span class="comment">^--- This is the type name</span>

<span class="comment">// Declaration is clean and matches FreeRTOS style</span>
<span class="type">sensor_data_t</span> reading;  <span class="comment">// Perfect!</span></div>
        </div>

        <div class="success-box">
            <strong>üí° Naming Convention:</strong> Add <code>_t</code> suffix to type names (e.g., <code>sensor_data_t</code>, <code>gps_position_t</code>).<br>
            This matches FreeRTOS style: <code>TaskHandle_t</code>, <code>QueueHandle_t</code>, <code>BaseType_t</code>
        </div>

        <h2>üé® Struct Initialization - C vs C++</h2>

        <div class="comparison">
            <div class="good">
                <h3>‚úÖ Positional (Always Works)</h3>
                <div class="code-block"><span class="type">sensor_data_t</span> reading = {
    <span class="number">1234</span>,    <span class="comment">// timestamp</span>
    <span class="number">1</span>,       <span class="comment">// sensor_id</span>
    <span class="number">23.5f</span>    <span class="comment">// temperature</span>
};</div>
                <p><strong>Order matters!</strong><br>Values must match field order exactly.</p>
            </div>
            
            <div class="good">
                <h3>‚úÖ Designated (C99/C++20)</h3>
                <div class="code-block"><span class="type">sensor_data_t</span> reading = {
    .timestamp = <span class="number">1234</span>,
    .sensor_id = <span class="number">1</span>,
    .temperature = <span class="number">23.5f</span>
};</div>
                <p><strong>Order independent!</strong><br>Explicit field names prevent errors.</p>
            </div>
        </div>

        <div class="comparison">
            <div class="good">
                <h3>‚úÖ Field Assignment (Always Works)</h3>
                <div class="code-block"><span class="type">sensor_data_t</span> reading;
reading.timestamp = <span class="number">1234</span>;
reading.sensor_id = <span class="number">1</span>;
reading.temperature = <span class="number">23.5f</span>;</div>
                <p><strong>Most flexible!</strong><br>Works in all contexts including loops.</p>
            </div>
            
            <div class="bad">
                <h3>‚ùå Aggregate (C only)</h3>
                <div class="code-block"><span class="comment">// Inside loop - won't compile in C++!</span>
reading = {<span class="number">1234</span>, <span class="number">1</span>, <span class="number">23.5f</span>};

<span class="comment">// Error: expected expression</span></div>
                <p><strong>Avoid in C++!</strong><br>Only works at declaration in C++.</p>
            </div>
        </div>

        <div class="warning-box">
            <strong>‚ö†Ô∏è Your Exercise Issue:</strong><br>
            You wrote: <code>dataToSend = {timeStamp*800, 1, 0.2f};</code><br>
            This is aggregate initialization which doesn't work in C++ outside of declaration.<br>
            <strong>Solution:</strong> Use field assignment or declare new struct each iteration.
        </div>

        <h2>üíæ Memory Layout and Padding</h2>

        <div class="concept-box">
            <h3>Why sizeof() Surprises You</h3>
            <p>You might expect: 4 bytes + 1 byte + 4 bytes = <strong>9 bytes</strong></p>
            <p>Reality: <strong>12 bytes!</strong> Why?</p>
        </div>

        <div class="memory-diagram">
            <h3>Memory Layout Visualization</h3>
            <div class="mermaid">
graph LR
    A[timestamp<br/>4 bytes<br/>offset 0] --> B[sensor_id<br/>1 byte<br/>offset 4]
    B --> C[PADDING<br/>3 bytes<br/>offset 5]
    C --> D[temperature<br/>4 bytes<br/>offset 8]
    
    style A fill:#50fa7b
    style B fill:#8be9fd
    style C fill:#ff5555
    style D fill:#bd93f9
            </div>
            
            <table>
                <tr>
                    <th>Offset</th>
                    <th>Size</th>
                    <th>Field</th>
                    <th>Why?</th>
                </tr>
                <tr>
                    <td>0-3</td>
                    <td>4 bytes</td>
                    <td>timestamp (uint32_t)</td>
                    <td>Aligned to 4-byte boundary ‚úì</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>1 byte</td>
                    <td>sensor_id (uint8_t)</td>
                    <td>Packed after timestamp</td>
                </tr>
                <tr>
                    <td>5-7</td>
                    <td>3 bytes</td>
                    <td><strong>PADDING</strong></td>
                    <td>Align next field to 4 bytes</td>
                </tr>
                <tr>
                    <td>8-11</td>
                    <td>4 bytes</td>
                    <td>temperature (float)</td>
                    <td>Aligned to 4-byte boundary ‚úì</td>
                </tr>
                <tr>
                    <td><strong>Total</strong></td>
                    <td><strong>12 bytes</strong></td>
                    <td colspan="2"><code>sizeof(sensor_data_t) == 12</code></td>
                </tr>
            </table>
        </div>

        <div class="concept-box">
            <h3>Why Does Padding Exist?</h3>
            <ul>
                <li><strong>CPU Efficiency:</strong> CPUs read memory in aligned chunks (4 bytes on 32-bit systems)</li>
                <li><strong>Access Speed:</strong> Reading unaligned data requires multiple memory reads (slower!)</li>
                <li><strong>Some CPUs:</strong> Can't access unaligned data at all (bus fault/exception)</li>
                <li><strong>Trade-off:</strong> Waste 3 bytes of memory to gain speed and compatibility</li>
            </ul>
        </div>

        <div class="warning-box">
            <strong>‚ö†Ô∏è Critical Rule for Queues:</strong><br>
            ALWAYS use <code>sizeof(your_struct_t)</code>, NEVER hardcode sizes!<br><br>
            <code>xQueueCreate(10, <strong>sizeof(sensor_data_t)</strong>);</code>  ‚úÖ<br>
            <code>xQueueCreate(10, <strong>9</strong>);</code>  ‚ùå Wrong! Memory corruption!
        </div>

        <h2>üì¨ Queuing Structs - How It Works</h2>

        <div class="concept-box">
            <h3>The Queue Copies Everything</h3>
            <div class="mermaid">
sequenceDiagram
    participant P as Producer Task
    participant Q as Queue (12 bytes per item)
    participant C as Consumer Task
    
    P->>P: Create struct<br/>sensor_data_t data
    P->>P: Fill fields<br/>timestamp, id, value
    P->>Q: xQueueSend(&data, ...)
    Note over Q: Queue copies<br/>ALL 12 bytes<br/>(including padding)
    Q->>C: xQueueReceive(&buffer, ...)
    Note over C: Queue copies<br/>12 bytes into<br/>consumer's buffer
    C->>C: Access fields<br/>buffer.timestamp, etc.
            </div>
        </div>

        <div class="code-block"><span class="comment">// Producer Task</span>
<span class="type">sensor_data_t</span> data;
data.timestamp = <span class="function">xTaskGetTickCount</span>();
data.sensor_id = <span class="number">1</span>;
data.temperature = <span class="number">23.5f</span>;

<span class="function">xQueueSend</span>(queue, &data, portMAX_DELAY);
<span class="comment">               ^--- Address of struct</span>
<span class="comment">// Queue copies all 12 bytes from &data</span>
<span class="comment">// data can be safely reused immediately</span>

<span class="comment">// Consumer Task</span>
<span class="type">sensor_data_t</span> received;
<span class="function">xQueueReceive</span>(queue, &received, portMAX_DELAY);
<span class="comment">                  ^--- Address where to copy to</span>
<span class="comment">// Queue copies 12 bytes into received</span>
<span class="comment">// Now received.timestamp, received.sensor_id, etc. are valid</span></div>

        <div class="success-box">
            <strong>‚úÖ Why Copying is Safe:</strong>
            <ul>
                <li>No shared memory between tasks (no race conditions)</li>
                <li>Producer can reuse local struct immediately</li>
                <li>Consumer gets independent copy</li>
                <li>Padding bytes are copied too (no corruption)</li>
            </ul>
        </div>

        <h2>üñ®Ô∏è Format Specifiers for Struct Fields</h2>

        <div class="comparison">
            <div class="bad">
                <h3>‚ùå Wrong Format Specifiers</h3>
                <div class="code-block"><span class="comment">// Your initial code</span>
<span class="function">ESP_LOGI</span>(TAG, <span class="string">"Timestamp: %u ms"</span>, 
         data.timestamp);
<span class="comment">// %u assumes 'int' but uint32_t</span>
<span class="comment">// might be 'long' on some platforms!</span></div>
            </div>
            
            <div class="good">
                <h3>‚úÖ Correct Format Specifiers</h3>
                <div class="code-block"><span class="comment">// Platform-safe version</span>
<span class="function">ESP_LOGI</span>(TAG, <span class="string">"Timestamp: %lu ms"</span>,
         (<span class="type">unsigned long</span>)data.timestamp);
<span class="comment">// Cast to match format specifier</span></div>
            </div>
        </div>

        <table>
            <tr>
                <th>C Type</th>
                <th>Format</th>
                <th>Notes</th>
            </tr>
            <tr>
                <td>uint8_t</td>
                <td>%u or %hhu</td>
                <td>Promoted to int in varargs</td>
            </tr>
            <tr>
                <td>uint16_t</td>
                <td>%u or %hu</td>
                <td>Promoted to int in varargs</td>
            </tr>
            <tr>
                <td>uint32_t</td>
                <td>%lu</td>
                <td>Cast to (unsigned long)</td>
            </tr>
            <tr>
                <td>int32_t</td>
                <td>%ld</td>
                <td>Cast to (long)</td>
            </tr>
            <tr>
                <td>float</td>
                <td>%.2f</td>
                <td>Promoted to double in varargs</td>
            </tr>
            <tr>
                <td>double</td>
                <td>%.2f or %.2lf</td>
                <td>Standard format</td>
            </tr>
        </table>

        <div class="warning-box">
            <strong>‚ö†Ô∏è Why This Matters:</strong><br>
            Wrong format specifiers can cause:<br>
            ‚Ä¢ Incorrect output values<br>
            ‚Ä¢ Stack corruption on some platforms<br>
            ‚Ä¢ Crashes or undefined behavior<br>
            ‚Ä¢ Nightmare debugging sessions
        </div>

        <h2>üéØ Real-World Embedded Struct Examples</h2>

        <div class="concept-box">
            <h3>Sensor Reading</h3>
            <div class="code-block"><span class="keyword">typedef struct</span> {
    <span class="type">uint32_t</span> timestamp_ms;
    <span class="type">uint8_t</span> sensor_id;
    <span class="type">float</span> temperature_c;
    <span class="type">float</span> humidity_percent;
    <span class="type">uint16_t</span> pressure_hpa;
} <span class="type">bme280_reading_t</span>;</div>

            <h3>GPS Position</h3>
            <div class="code-block"><span class="keyword">typedef struct</span> {
    <span class="type">double</span> latitude;
    <span class="type">double</span> longitude;
    <span class="type">float</span> altitude_m;
    <span class="type">uint8_t</span> satellites;
    <span class="type">uint8_t</span> fix_quality;
    <span class="type">uint32_t</span> timestamp_ms;
} <span class="type">gps_position_t</span>;</div>

            <h3>UART Packet</h3>
            <div class="code-block"><span class="keyword">typedef struct</span> {
    <span class="type">uint8_t</span> header;
    <span class="type">uint8_t</span> command;
    <span class="type">uint16_t</span> length;
    <span class="type">uint8_t</span> data[<span class="number">64</span>];
    <span class="type">uint16_t</span> checksum;
} <span class="type">uart_packet_t</span>;</div>

            <h3>Button Event</h3>
            <div class="code-block"><span class="keyword">typedef struct</span> {
    <span class="type">gpio_num_t</span> pin;
    <span class="type">uint32_t</span> press_timestamp;
    <span class="type">uint32_t</span> release_timestamp;
    <span class="type">bool</span> is_long_press;
} <span class="type">button_event_t</span>;</div>
        </div>

        <h2>ü§î Critical Thinking Questions</h2>

        <div class="question">
            <strong>Q1: What's the memory cost of a 10-item queue of structs vs integers?</strong>
            <div class="answer">
                <strong>Answer:</strong><br>
                Integer queue: 10 √ó sizeof(int) = 10 √ó 4 = <strong>40 bytes</strong><br>
                Struct queue: 10 √ó sizeof(sensor_data_t) = 10 √ó 12 = <strong>120 bytes</strong><br>
                <strong>3x more memory!</strong> But you get organized, type-safe data.<br>
                Trade-off: Memory vs code clarity/safety
            </div>
        </div>

        <div class="question">
            <strong>Q2: When would you queue pointers to structs instead of copying?</strong>
            <div class="answer">
                <strong>Answer:</strong><br>
                ‚Ä¢ <strong>Large structs</strong> (>64 bytes) - copying is expensive<br>
                ‚Ä¢ <strong>Variable-length data</strong> (strings, arrays) - can't predict size<br>
                ‚Ä¢ <strong>DMA buffers</strong> - hardware writes to specific memory<br>
                <br>
                <strong>BUT:</strong> Now you need:<br>
                ‚Ä¢ Dynamic memory allocation (malloc/free)<br>
                ‚Ä¢ Careful ownership tracking (who frees it?)<br>
                ‚Ä¢ Potential memory leaks and fragmentation<br>
                <br>
                <strong>Rule:</strong> Copy small structs (<64 bytes), queue pointers for large data
            </div>
        </div>

        <div class="question">
            <strong>Q3: Why not use a global struct instead of queuing?</strong>
            <div class="answer">
                <strong>Answer:</strong><br>
                <strong>Race condition nightmare!</strong><br>
                <br>
                Producer writing: <code>global.timestamp = 1234;</code><br>
                <em>Context switch happens here!</em><br>
                Consumer reading: <code>log(global.timestamp, global.sensor_id);</code> ‚Üê Old sensor_id!<br>
                Producer resumes: <code>global.sensor_id = 2;</code><br>
                <br>
                Consumer got <strong>mismatched data</strong> - timestamp from reading #1, sensor_id from reading #2!<br>
                <br>
                <strong>Queue guarantees:</strong> Each item is atomic - all fields from same reading
            </div>
        </div>

        <div class="question">
            <strong>Q4: How would you reduce padding waste?</strong>
            <div class="answer">
                <strong>Answer:</strong> Order fields by size (largest first)<br>
                <br>
                <strong>Before (12 bytes with 3-byte padding):</strong><br>
                <code>uint32_t timestamp; uint8_t id; float value;</code><br>
                [4][1][pad:3][4] = 12 bytes<br>
                <br>
                <strong>After (still 12 bytes but optimal):</strong><br>
                <code>uint32_t timestamp; float value; uint8_t id;</code><br>
                [4][4][1][pad:3] = 12 bytes<br>
                <br>
                <strong>Best (no padding if you can):</strong><br>
                <code>uint32_t timestamp; uint32_t value_as_int; uint8_t id;</code><br>
                [4][4][1][pad:3] = 12 bytes<br>
                <br>
                Or use <code>__attribute__((packed))</code> but <strong>this hurts performance!</strong>
            </div>
        </div>

        <h2>üìã Best Practices Summary</h2>

        <div class="success-box">
            <h3>‚úÖ DO:</h3>
            <ul>
                <li>Use <code>typedef struct</code> with <code>_t</code> suffix</li>
                <li>Always use <code>sizeof(struct)</code> for queue item size</li>
                <li>Use designated initializers when possible (.field = value)</li>
                <li>Cast uint32_t to (unsigned long) for %lu format</li>
                <li>Group related data into structs</li>
                <li>Order struct fields by size to minimize padding</li>
            </ul>
        </div>

        <div class="warning-box">
            <h3>‚ùå DON'T:</h3>
            <ul>
                <li>Hardcode struct sizes (use sizeof!)</li>
                <li>Use aggregate initialization in C++ loops</li>
                <li>Assume no padding (always check sizeof)</li>
                <li>Use %u for uint32_t (use %lu)</li>
                <li>Queue pointers to local variables</li>
                <li>Use global structs for inter-task data (race conditions!)</li>
            </ul>
        </div>

        <h2>üéì What You've Mastered</h2>

        <div class="concept-box">
            <ul>
                <li>‚úÖ <strong>typedef struct</strong> pattern for clean type definitions</li>
                <li>‚úÖ <strong>Memory alignment and padding</strong> - why sizeof() matters</li>
                <li>‚úÖ <strong>Initialization methods</strong> - positional, designated, field assignment</li>
                <li>‚úÖ <strong>Queue data copying</strong> - safety through independence</li>
                <li>‚úÖ <strong>Format specifiers</strong> - platform-safe printf</li>
                <li>‚úÖ <strong>Producer-Consumer with structs</strong> - real-world data patterns</li>
            </ul>
        </div>

        <div class="success-box">
            <h3>üöÄ Next Steps: Day 5 - Semaphores & Mutexes</h3>
            <p>Now that you can pass data between tasks with queues, you'll learn to:</p>
            <ul>
                <li><strong>Protect shared resources</strong> with mutexes</li>
                <li><strong>Signal events</strong> with binary semaphores</li>
                <li><strong>Manage resource pools</strong> with counting semaphores</li>
                <li><strong>Avoid race conditions</strong> in critical sections</li>
            </ul>
        </div>
    </div>

    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });
    </script>
</body>
</html>