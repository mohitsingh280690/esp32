<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Days 6-7 Practice Project - Multi-Task LED Controller</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #FA8BFF 0%, #2BD2FF 52%, #2BFF88 90%);
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        header {
            background: linear-gradient(135deg, #FA8BFF 0%, #2BD2FF 52%, #2BFF88 90%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        header h1 { font-size: 2.8em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        header p { font-size: 1.3em; opacity: 0.95; }
        .content { padding: 40px; }
        h2 {
            color: #FA8BFF;
            border-bottom: 3px solid #FA8BFF;
            padding-bottom: 10px;
            margin: 30px 0 20px 0;
        }
        h3 { color: #2BD2FF; margin: 20px 0 10px 0; }
        .objective-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            margin: 20px 0;
            border-radius: 10px;
            font-size: 1.1em;
        }
        .objective-box h3 { color: white; }
        .concept-box {
            background: #f8f9fa;
            border-left: 4px solid #2BD2FF;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Consolas, Monaco, monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre;
        }
        .requirement {
            background: #e8f4f8;
            border-left: 4px solid #2196f3;
            padding: 20px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .requirement h3 { color: #1976d2; margin-top: 0; }
        .pattern-demo {
            background: #2d2d2d;
            color: #00ff00;
            padding: 20px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            margin: 15px 0;
        }
        .hardware-list {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .design-card {
            background: #d4edda;
            border: 2px solid #28a745;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
        }
        .key-point {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background: linear-gradient(135deg, #FA8BFF 0%, #2BD2FF 100%);
            color: white;
        }
        tr:hover { background: #f5f5f5; }
        .mermaid { text-align: center; margin: 30px 0; }
        .task-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .task-card {
            border: 2px solid;
            border-radius: 8px;
            padding: 20px;
        }
        .task1 { border-color: #dc3545; background: #f8d7da; }
        .task2 { border-color: #28a745; background: #d4edda; }
        .task3 { border-color: #007bff; background: #cfe2ff; }
        .task4 { border-color: #ffc107; background: #fff3cd; }
        .checklist {
            list-style: none;
            padding-left: 0;
        }
        .checklist li {
            padding: 8px 0;
            padding-left: 30px;
            position: relative;
        }
        .checklist li:before {
            content: "‚òê";
            position: absolute;
            left: 0;
            font-size: 1.4em;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéØ Days 6-7: Multi-Task LED Controller</h1>
            <p>Practice Project - Consolidating Week 1 Concepts</p>
        </header>
        
        <div class="content">
            <div class="objective-box">
                <h2 style="color: white; border: none;">üéØ PRIMARY OBJECTIVE</h2>
                <p>Build a complete embedded system that integrates ALL Week 1 FreeRTOS concepts into one functional project:</p>
                <ul style="margin-top: 15px; font-size: 1.05em;">
                    <li>‚úÖ <strong>Tasks</strong> - Multiple concurrent execution threads (Days 1-2)</li>
                    <li>‚úÖ <strong>Priorities</strong> - Strategic CPU time allocation (Day 3)</li>
                    <li>‚úÖ <strong>Queues</strong> - Inter-task data communication (Day 4)</li>
                    <li>‚úÖ <strong>Semaphores & Mutexes</strong> - Resource protection & synchronization (Day 5)</li>
                </ul>
                <p style="margin-top: 15px; font-size: 1.1em;"><strong>Real-World Scenario:</strong> Multi-input LED pattern controller with user interaction, serial commands, and status reporting.</p>
            </div>

            <h2>üèóÔ∏è System Architecture</h2>
            <div class="mermaid">
                graph TD
                    A[Button Handler<br/>Priority 5] -->|Pattern Command| Q1[Pattern Queue]
                    B[Serial Parser<br/>Priority 2] -->|Pattern Command| Q1
                    B -->|Speed Command| Q2[Speed Queue]
                    Q1 --> C[Pattern Sequencer<br/>Priority 3]
                    Q2 --> C
                    C --> D[4 LEDs<br/>GPIO Control]
                    E[Status Reporter<br/>Priority 1] -.->|Uses Mutex| F[UART Output]
                    B -.->|Uses Mutex| F
                    
                    style A fill:#d4edda
                    style B fill:#cfe2ff
                    style C fill:#f8d7da
                    style E fill:#fff3cd
                    style D fill:#ffd700
                    style F fill:#e3f2fd
            </div>

            <h2>üìã System Requirements</h2>

            <div class="task-grid">
                <div class="task-card task1">
                    <h3>Task 1: Pattern Sequencer</h3>
                    <p><strong>Priority:</strong> 3 (Medium)</p>
                    <ul class="checklist">
                        <li>Reads pattern commands from queue</li>
                        <li>Controls 4 LEDs based on pattern</li>
                        <li>4 patterns: Knight Rider, Blink, Alternating, Random</li>
                        <li>Adjustable speed (delay between steps)</li>
                        <li>Non-blocking queue reads</li>
                    </ul>
                </div>

                <div class="task-card task2">
                    <h3>Task 2: Button Handler</h3>
                    <p><strong>Priority:</strong> 5 (Highest)</p>
                    <ul class="checklist">
                        <li>Monitors button press (polling/interrupt)</li>
                        <li>Cycles through patterns on press</li>
                        <li>Sends command to pattern queue</li>
                        <li>Response time &lt; 50ms</li>
                        <li>Debouncing implemented</li>
                    </ul>
                </div>

                <div class="task-card task3">
                    <h3>Task 3: Serial Command Parser</h3>
                    <p><strong>Priority:</strong> 2 (Low-Medium)</p>
                    <ul class="checklist">
                        <li>Reads UART commands</li>
                        <li>Commands: pattern, speed, status</li>
                        <li>Validates input</li>
                        <li>Sends to appropriate queues</li>
                        <li>Uses mutex for serial output</li>
                    </ul>
                </div>

                <div class="task-card task4">
                    <h3>Task 4: Status Reporter</h3>
                    <p><strong>Priority:</strong> 1 (Lowest)</p>
                    <ul class="checklist">
                        <li>Prints status every 5 seconds</li>
                        <li>Shows: pattern, speed, uptime</li>
                        <li>Task states if possible</li>
                        <li>Uses mutex for UART protection</li>
                        <li>Runs in background</li>
                    </ul>
                </div>
            </div>

            <h2>üé® LED Patterns to Implement</h2>

            <div class="pattern-demo">
<strong>Pattern 0 - Knight Rider (Sweeping):</strong>
Step 1: ‚óè‚óã‚óã‚óã  Step 2: ‚óã‚óè‚óã‚óã  Step 3: ‚óã‚óã‚óè‚óã  Step 4: ‚óã‚óã‚óã‚óè
Step 5: ‚óã‚óã‚óè‚óã  Step 6: ‚óã‚óè‚óã‚óã  Step 7: ‚óè‚óã‚óã‚óã  [repeat]

<strong>Pattern 1 - Blink All Together:</strong>
Step 1: ‚óè‚óè‚óè‚óè  Step 2: ‚óã‚óã‚óã‚óã  Step 3: ‚óè‚óè‚óè‚óè  Step 4: ‚óã‚óã‚óã‚óã  [repeat]

<strong>Pattern 2 - Alternating Pairs:</strong>
Step 1: ‚óè‚óè‚óã‚óã  Step 2: ‚óã‚óã‚óè‚óè  Step 3: ‚óè‚óè‚óã‚óã  Step 4: ‚óã‚óã‚óè‚óè  [repeat]

<strong>Pattern 3 - Random:</strong>
Each step: Random LEDs on/off (use esp_random())
            </div>

            <h2>üîß Hardware Configuration</h2>
            <div class="hardware-list">
                <h3>Required Components:</h3>
                <table style="background: white; margin-top: 10px;">
                    <tr>
                        <th>Component</th>
                        <th>GPIO Pin</th>
                        <th>Purpose</th>
                    </tr>
                    <tr>
                        <td>LED 1</td>
                        <td>GPIO 4 (D4)</td>
                        <td>Pattern display</td>
                    </tr>
                    <tr>
                        <td>LED 2</td>
                        <td>GPIO 16 (D16)</td>
                        <td>Pattern display</td>
                    </tr>
                    <tr>
                        <td>LED 3</td>
                        <td>GPIO 17 (D17)</td>
                        <td>Pattern display</td>
                    </tr>
                    <tr>
                        <td>LED 4</td>
                        <td>GPIO 5 (D5)</td>
                        <td>Pattern display</td>
                    </tr>
                    <tr>
                        <td>Button</td>
                        <td>GPIO 15 (D15)</td>
                        <td>Pattern cycling (pulled up)</td>
                    </tr>
                    <tr>
                        <td>Serial Console</td>
                        <td>USB UART</td>
                        <td>Commands & status (115200 baud)</td>
                    </tr>
                </table>
            </div>

            <h2>üì° Serial Commands</h2>
            <div class="code-block">
Command Format:

pattern &lt;0-3&gt;     - Change LED pattern
  Example: pattern 2

speed &lt;50-1000&gt;   - Change animation speed (ms delay)
  Example: speed 200

status           - Display current system status
  Example: status

Expected Output:
> pattern 1
Pattern changed to: Blink All

> speed 300
Speed set to: 300ms

> status
=== System Status ===
Current Pattern: Knight Rider (0)
Speed: 500ms
Uptime: 125 seconds
Tasks: 4 running
            </div>

            <h2>üí° Design Decisions & Rationale</h2>

            <div class="design-card">
                <h3>Why These Priorities?</h3>
                <table style="background: white; margin-top: 10px;">
                    <tr>
                        <th>Task</th>
                        <th>Priority</th>
                        <th>Reasoning</th>
                    </tr>
                    <tr>
                        <td><strong>Button Handler</strong></td>
                        <td>5 (Highest)</td>
                        <td>User interaction must feel instant (&lt;50ms response). Human perception is critical.</td>
                    </tr>
                    <tr>
                        <td><strong>Pattern Sequencer</strong></td>
                        <td>3 (Medium)</td>
                        <td>LED timing is visible but slight jitter acceptable. Main application logic.</td>
                    </tr>
                    <tr>
                        <td><strong>Serial Parser</strong></td>
                        <td>2 (Low-Med)</td>
                        <td>Typing is slow. Can tolerate 100-200ms latency without user noticing.</td>
                    </tr>
                    <tr>
                        <td><strong>Status Reporter</strong></td>
                        <td>1 (Lowest)</td>
                        <td>Background task. Runs when nothing else needs CPU. 5-second interval.</td>
                    </tr>
                </table>
            </div>

            <div class="design-card">
                <h3>Queue Sizing Strategy</h3>
                <ul>
                    <li><strong>Pattern Queue:</strong> Size 5 - Buffer button presses and serial commands</li>
                    <li><strong>Speed Queue:</strong> Size 3 - Only serial commands, less frequent</li>
                    <li><strong>Rationale:</strong> Prevent data loss during burst input while keeping memory usage reasonable</li>
                </ul>
            </div>

            <div class="design-card">
                <h3>Mutex Usage</h3>
                <ul>
                    <li><strong>UART Mutex:</strong> Protects serial output from interleaving</li>
                    <li><strong>Shared by:</strong> Serial Parser (command responses) + Status Reporter (periodic output)</li>
                    <li><strong>Why needed:</strong> Without mutex, outputs would corrupt each other</li>
                    <li><strong>Example problem:</strong> "Patter[Status: 123]n changed" ‚Üê Interleaved output!</li>
                </ul>
            </div>

            <h2>üß† C Concepts Applied in This Project</h2>

            <div class="concept-box">
                <h3>1. Enums for Pattern Selection</h3>
                <div class="code-block">
typedef enum {
    PATTERN_KNIGHT_RIDER = 0,
    PATTERN_BLINK_ALL = 1,
    PATTERN_ALTERNATING = 2,
    PATTERN_RANDOM = 3
} pattern_t;

// Why enum? Type safety + readability
pattern_t current = PATTERN_KNIGHT_RIDER;  // Clear intent
                </div>
            </div>

            <div class="concept-box">
                <h3>2. Struct for Queue Messages</h3>
                <div class="code-block">
typedef struct {
    uint8_t pattern_id;
    uint32_t timestamp;
} pattern_cmd_t;

typedef struct {
    uint16_t delay_ms;
} speed_cmd_t;

// Why structs? Extensible - can add fields later
                </div>
            </div>

            <div class="concept-box">
                <h3>3. Arrays for GPIO Management</h3>
                <div class="code-block">
const gpio_num_t led_pins[4] = {
    GPIO_NUM_4,   // LED 1
    GPIO_NUM_16,  // LED 2
    GPIO_NUM_17,  // LED 3
    GPIO_NUM_5    // LED 4
};

// Loop through LEDs easily
for (int i = 0; i < 4; i++) {
    gpio_set_level(led_pins[i], state[i]);
}
                </div>
            </div>

            <div class="concept-box">
                <h3>4. Function Pointers for Pattern Functions</h3>
                <div class="code-block">
void pattern_knight_rider(void);
void pattern_blink_all(void);
void pattern_alternating(void);
void pattern_random(void);

// Array of function pointers
void (*patterns[])(void) = {
    pattern_knight_rider,
    pattern_blink_all,
    pattern_alternating,
    pattern_random
};

// Execute pattern by index
patterns[current_pattern]();  // Calls function!
                </div>
            </div>

            <h2>üéì Learning Objectives Checklist</h2>

            <div class="key-point">
                <h3>By completing this project, you will master:</h3>
                <ul class="checklist">
                    <li><strong>Task Management:</strong> Creating, prioritizing, and coordinating multiple tasks</li>
                    <li><strong>Queue Communication:</strong> Sending commands between tasks safely</li>
                    <li><strong>Mutex Usage:</strong> Protecting shared resources (UART)</li>
                    <li><strong>Priority Decisions:</strong> Understanding real-world priority assignment</li>
                    <li><strong>GPIO Control:</strong> Managing multiple hardware pins efficiently</li>
                    <li><strong>Input Handling:</strong> Button debouncing and serial parsing</li>
                    <li><strong>System Design:</strong> Architecting multi-task embedded systems</li>
                    <li><strong>State Machines:</strong> Pattern sequencing logic</li>
                    <li><strong>C Data Structures:</strong> Enums, structs, arrays, function pointers</li>
                    <li><strong>Real-Time Thinking:</strong> Timing constraints and responsiveness</li>
                </ul>
            </div>

            <h2>üöÄ Implementation Strategy</h2>

            <div class="concept-box">
                <h3>Recommended Order:</h3>
                <ol>
                    <li><strong>Start Simple:</strong> Get one LED blinking with Task 1 only</li>
                    <li><strong>Add Patterns:</strong> Implement all 4 patterns in sequencer</li>
                    <li><strong>Add Button:</strong> Create Task 2, test pattern cycling</li>
                    <li><strong>Add Queues:</strong> Button sends to queue, sequencer reads</li>
                    <li><strong>Add Serial:</strong> Create Task 3 for commands</li>
                    <li><strong>Add Mutex:</strong> Protect UART with mutex</li>
                    <li><strong>Add Status:</strong> Create Task 4 for reporting</li>
                    <li><strong>Test & Debug:</strong> Verify all interactions work</li>
                    <li><strong>Optimize:</strong> Fine-tune delays, priorities, queue sizes</li>
                </ol>
            </div>

            <h2>üîç Critical Thinking Questions</h2>

            <div class="concept-box">
                <ol>
                    <li><strong>What happens if button is pressed rapidly?</strong><br>
                    Queue buffers commands. If queue fills, new commands dropped (or block).</li>
                    
                    <li><strong>Why does status reporter need lowest priority?</strong><br>
                    Non-urgent. Should only run when CPU otherwise idle. Doesn't affect user experience.</li>
                    
                    <li><strong>Could we use semaphore instead of queue for button?</strong><br>
                    No - semaphore signals "event happened" but doesn't pass WHICH pattern. Need data = need queue.</li>
                    
                    <li><strong>What if we removed the mutex?</strong><br>
                    UART output would interleave: "CurPat[Speed: 500]tern: Blink" ‚Üê garbled!</li>
                    
                    <li><strong>Why not make all tasks same priority?</strong><br>
                    Round-robin scheduling. Button might wait 75ms while status reporter prints. User notices lag!</li>
                    
                    <li><strong>How much stack does each task need?</strong><br>
                    Consider: local variables + function call depth + library usage. Start with 2048, measure, adjust.</li>
                </ol>
            </div>

            <h2>‚úÖ Success Criteria</h2>

            <div class="key-point">
                <p><strong>Your project is complete when:</strong></p>
                <ul>
                    <li>‚úÖ All 4 patterns display correctly on LEDs</li>
                    <li>‚úÖ Button press cycles patterns within 50ms</li>
                    <li>‚úÖ Serial commands work: pattern, speed, status</li>
                    <li>‚úÖ Status reports every 5 seconds without interrupting LED patterns</li>
                    <li>‚úÖ No garbled UART output (mutex working)</li>
                    <li>‚úÖ System runs continuously without crashes</li>
                    <li>‚úÖ Code is clean, commented, and organized</li>
                    <li>‚úÖ You can explain WHY each design decision was made</li>
                </ul>
            </div>

            <h2>üìö What Comes Next?</h2>
            <p>After completing this project, you'll move to <strong>Week 2: Hardware Peripherals</strong>, where you'll learn:</p>
            <ul>
                <li>GPIO interrupts (no more polling!)</li>
                <li>Hardware timers</li>
                <li>UART, I2C, SPI protocols</li>
                <li>ADC and DAC for analog signals</li>
            </ul>
            <p><strong>This project gives you the FreeRTOS foundation needed for all future embedded work!</strong></p>
        </div>
    </div>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</body>
</html>