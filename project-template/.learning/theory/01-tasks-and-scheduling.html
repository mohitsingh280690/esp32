<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FreeRTOS Tasks & Scheduling - ESP32 Tutorial</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        header h1 { font-size: 2.5em; margin-bottom: 10px; }
        header p { font-size: 1.2em; opacity: 0.9; }
        .content { padding: 40px; }
        h2 {
            color: #667eea;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            margin: 30px 0 20px 0;
        }
        h3 { color: #764ba2; margin: 20px 0 10px 0; }
        .concept-box {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Consolas, Monaco, monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre;
        }
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .success {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .key-point {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background: #667eea;
            color: white;
        }
        tr:hover { background: #f5f5f5; }
        .mermaid { text-align: center; margin: 30px 0; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìã FreeRTOS Tasks & Scheduling</h1>
            <p>Understanding Concurrent Execution on ESP32</p>
        </header>
        
        <div class="content">
            <h2>üéØ What Are Tasks?</h2>
            <div class="concept-box">
                <p><strong>Tasks</strong> are independent threads of execution that run concurrently. In FreeRTOS terminology:</p>
                <ul>
                    <li><strong>Task = Thread</strong> (same concept, different name)</li>
                    <li>Each task has its own stack, priority, and state</li>
                    <li>Tasks share CPU time through scheduling</li>
                    <li>Each task runs in an infinite loop</li>
                </ul>
            </div>

            <h3>Task Lifecycle</h3>
            <div class="mermaid">
                graph LR
                    A[Created] --> B[Ready]
                    B --> C[Running]
                    C --> B
                    C --> D[Blocked]
                    D --> B
                    C --> E[Suspended]
                    E --> B
                    C --> F[Deleted]
                    style C fill:#90ee90
                    style D fill:#ffcccb
                    style B fill:#add8e6
            </div>

            <h3>Task States Explained</h3>
            <table>
                <tr>
                    <th>State</th>
                    <th>Description</th>
                    <th>CPU Usage</th>
                </tr>
                <tr>
                    <td><strong>Ready</strong></td>
                    <td>Waiting for CPU time, can run immediately</td>
                    <td>0%</td>
                </tr>
                <tr>
                    <td><strong>Running</strong></td>
                    <td>Currently executing on CPU</td>
                    <td>100%</td>
                </tr>
                <tr>
                    <td><strong>Blocked</strong></td>
                    <td>Waiting for event (delay, queue, semaphore)</td>
                    <td>0%</td>
                </tr>
                <tr>
                    <td><strong>Suspended</strong></td>
                    <td>Explicitly suspended, won't run until resumed</td>
                    <td>0%</td>
                </tr>
            </table>

            <h2>‚öôÔ∏è Creating Tasks</h2>
            <div class="code-block">
BaseType_t xTaskCreate(
    TaskFunction_t pvTaskCode,    // Function pointer
    const char * const pcName,     // Task name (debugging)
    uint32_t usStackDepth,         // Stack size in words
    void *pvParameters,            // Task parameter
    UBaseType_t uxPriority,        // Priority (0-24)
    TaskHandle_t *pvCreatedTask    // Handle (can be NULL)
);
            </div>

            <h3>Example: Two Concurrent Tasks</h3>
            <div class="code-block">
void task1(void *pvParameter) {
    while(1) {
        ESP_LOGI("Task1", "Hello from Task 1");
        vTaskDelay(pdMS_TO_TICKS(1000));  // Must yield!
    }
}

void task2(void *pvParameter) {
    while(1) {
        ESP_LOGI("Task2", "Hello from Task 2");
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}

extern "C" void app_main(void) {
    xTaskCreate(&task1, "Task1", 2048, NULL, 5, NULL);
    xTaskCreate(&task2, "Task2", 2048, NULL, 5, NULL);
}
            </div>

            <div class="warning">
                <strong>‚ö†Ô∏è Critical Rule:</strong> Every task loop MUST call <code>vTaskDelay()</code> or another blocking function. Without it, the watchdog timer will reset your ESP32!
            </div>

            <h2>üéöÔ∏è Priority-Based Scheduling</h2>
            <div class="concept-box">
                <p><strong>Preemptive Priority Scheduling:</strong> Higher priority tasks always run first when READY.</p>
            </div>

            <div class="mermaid">
                graph TD
                    A[Scheduler Decision] --> B{Tasks in READY state?}
                    B -->|Yes| C[Find highest priority]
                    C --> D[Run that task]
                    D --> E{Task blocks/yields?}
                    E -->|Yes| A
                    E -->|No| F[Run until time slice expires]
                    F --> A
                    B -->|No| G[Run IDLE task]
                    G --> A
            </div>

            <h3>Priority Rules</h3>
            <table>
                <tr>
                    <th>Priority</th>
                    <th>Usage</th>
                </tr>
                <tr>
                    <td>0 (IDLE)</td>
                    <td>Reserved for IDLE task - feeds watchdog</td>
                </tr>
                <tr>
                    <td>1-5</td>
                    <td>Low priority background tasks</td>
                </tr>
                <tr>
                    <td>6-15</td>
                    <td>Normal priority application tasks</td>
                </tr>
                <tr>
                    <td>16-24</td>
                    <td>High priority time-critical tasks</td>
                </tr>
            </table>

            <div class="key-point">
                <strong>üîë Key Insight:</strong> Priority only matters when tasks are in READY state. A blocked task (in <code>vTaskDelay()</code>) doesn't compete for CPU regardless of priority.
            </div>

            <h2>üîÑ Context Switching</h2>
            <div class="concept-box">
                <p><strong>Context Switch:</strong> When the scheduler pauses one task and resumes another.</p>
                <ul>
                    <li>Save current task's registers, stack pointer, program counter</li>
                    <li>Load next task's saved context</li>
                    <li>Resume execution exactly where it left off</li>
                </ul>
            </div>

            <h3>When Context Switches Occur</h3>
            <ol>
                <li>Task calls <code>vTaskDelay()</code> - voluntarily yields</li>
                <li>Task blocks on queue/semaphore - waits for event</li>
                <li>Higher priority task becomes READY - preemption</li>
                <li>Time slice expires (equal priority tasks) - round-robin</li>
            </ol>

            <div class="mermaid">
                sequenceDiagram
                    participant S as Scheduler
                    participant T1 as Task 1 (Priority 5)
                    participant T2 as Task 2 (Priority 3)
                    
                    S->>T1: Run (highest priority)
                    T1->>T1: Execute code
                    T1->>S: vTaskDelay() - block
                    S->>T2: Run (next highest)
                    T2->>T2: Execute code
                    T2->>S: vTaskDelay() - block
                    Note over S: Delay expires
                    S->>T1: Run (higher priority)
                    T1->>T1: Resume execution
            </div>

            <h2>üîß Dynamic Priority Control</h2>
            <div class="code-block">
// Get current task's priority
UBaseType_t priority = uxTaskPriorityGet(NULL);  // NULL = self

// Change another task's priority
vTaskPrioritySet(taskHandle, newPriority);

// Change own priority
vTaskPrioritySet(NULL, newPriority);
            </div>

            <div class="success">
                <strong>‚úÖ Pro Tip:</strong> Use <code>NULL</code> to refer to the currently running task. No need to store a handle!
            </div>

            <h2>üìä Critical Thinking Questions</h2>
            <div class="concept-box">
                <ol>
                    <li><strong>Why must tasks call vTaskDelay()?</strong><br>
                    To yield CPU and allow IDLE task to run (feeds watchdog, housekeeping).</li>
                    
                    <li><strong>What happens if all tasks are blocked?</strong><br>
                    IDLE task runs, which can put CPU in low-power mode.</li>
                    
                    <li><strong>Can low priority task run while high priority exists?</strong><br>
                    Only if high priority task is BLOCKED. READY high priority always preempts.</li>
                    
                    <li><strong>What's the overhead of context switching?</strong><br>
                    ~50-100 CPU cycles on ESP32. Negligible for most applications.</li>
                    
                    <li><strong>How many tasks can ESP32 run?</strong><br>
                    Limited by RAM. Each task needs stack (2KB minimum). Typically 10-50 tasks.</li>
                </ol>
            </div>

            <h2>‚ö° Best Practices</h2>
            <ul>
                <li>‚úÖ Always include <code>vTaskDelay()</code> in task loops</li>
                <li>‚úÖ Use meaningful task names for debugging</li>
                <li>‚úÖ Allocate sufficient stack (2048+ words typical)</li>
                <li>‚úÖ Use priorities thoughtfully - most tasks can be same priority</li>
                <li>‚úÖ Reserve high priorities (20+) for time-critical work</li>
                <li>‚ùå Don't use delays shorter than 10ms unless necessary (UART overhead)</li>
                <li>‚ùå Don't create excessive tasks - use event-driven design</li>
                <li>‚ùå Don't busy-wait in loops - use blocking calls</li>
            </ul>

            <h2>üéì What You've Learned</h2>
            <div class="success">
                <ul>
                    <li>Tasks are independent threads with their own stack and priority</li>
                    <li>Preemptive scheduling: higher priority READY tasks always run first</li>
                    <li>Context switching saves/restores task state transparently</li>
                    <li>Blocking moves task out of READY state, freeing CPU</li>
                    <li>IDLE task is critical - must run to feed watchdog</li>
                    <li>Priority only matters when tasks compete (both READY)</li>
                    <li>Function pointers enable passing task code to xTaskCreate()</li>
                </ul>
            </div>
        </div>
    </div>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</body>
</html>