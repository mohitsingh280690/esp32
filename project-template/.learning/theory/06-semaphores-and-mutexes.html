<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semaphores and Mutexes - ESP32 FreeRTOS Tutorial</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #667eea;
            border-bottom: 4px solid #667eea;
            padding-bottom: 15px;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        h2 {
            color: #764ba2;
            margin-top: 40px;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-left: 5px solid #764ba2;
            padding-left: 15px;
        }
        
        h3 {
            color: #667eea;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .concept-box {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            border-left: 5px solid #667eea;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
        }
        
        .warning-box {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
        }
        
        .danger-box {
            background: #f8d7da;
            border-left: 5px solid #dc3545;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
        }
        
        .success-box {
            background: #d4edda;
            border-left: 5px solid #28a745;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
        }
        
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', Consolas, Monaco, monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre;
        }
        
        .keyword { color: #ff79c6; font-weight: bold; }
        .type { color: #8be9fd; }
        .function { color: #50fa7b; }
        .comment { color: #6272a4; font-style: italic; }
        .string { color: #f1fa8c; }
        .number { color: #bd93f9; }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 25px 0;
        }
        
        .comparison > div {
            padding: 20px;
            border-radius: 8px;
        }
        
        .bad {
            background: #f8d7da;
            border: 2px solid #dc3545;
        }
        
        .good {
            background: #d4edda;
            border: 2px solid #28a745;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
        }
        
        th, td {
            border: 1px solid #dee2e6;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .question {
            background: #e7f3ff;
            border-left: 5px solid #2196F3;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
        }
        
        .answer {
            background: #f0f0f0;
            padding: 15px;
            margin-top: 10px;
            border-radius: 5px;
            font-style: italic;
        }
        
        ul, ol {
            margin: 15px 0;
            padding-left: 30px;
        }
        
        li {
            margin: 10px 0;
        }
        
        strong {
            color: #667eea;
        }
        
        .vs-box {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
            margin: 30px 0;
        }
        
        .vs-box > div:first-child,
        .vs-box > div:last-child {
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #667eea;
        }
        
        .vs-text {
            font-size: 2em;
            font-weight: bold;
            color: #764ba2;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîí Semaphores and Mutexes in FreeRTOS</h1>
        
        <div class="concept-box">
            <h3>üéØ What You'll Learn</h3>
            <ul>
                <li><strong>Binary Semaphores</strong> - Event signaling between tasks</li>
                <li><strong>Mutexes</strong> - Protecting shared resources</li>
                <li><strong>Race Conditions</strong> - Why they happen and how to prevent them</li>
                <li><strong>Critical Sections</strong> - Safe zones for shared data access</li>
                <li><strong>volatile keyword</strong> - What it does and doesn't do</li>
            </ul>
        </div>

        <h2>üö¶ Semaphores vs Queues vs Mutexes</h2>
        
        <table>
            <tr>
                <th>Primitive</th>
                <th>Purpose</th>
                <th>Transfers Data?</th>
                <th>Use Case</th>
            </tr>
            <tr>
                <td><strong>Queue</strong></td>
                <td>Pass data between tasks</td>
                <td>‚úÖ Yes - copies data</td>
                <td>Sensor readings, commands, packets</td>
            </tr>
            <tr>
                <td><strong>Binary Semaphore</strong></td>
                <td>Signal events</td>
                <td>‚ùå No - just flag</td>
                <td>Button press, data ready, ISR‚ÜíTask</td>
            </tr>
            <tr>
                <td><strong>Mutex</strong></td>
                <td>Protect resources</td>
                <td>‚ùå No - lock/unlock</td>
                <td>Shared counter, UART, SPI bus</td>
            </tr>
            <tr>
                <td><strong>Counting Semaphore</strong></td>
                <td>Manage resource pool</td>
                <td>‚ùå No - count available</td>
                <td>3 UART ports, buffer pool</td>
            </tr>
        </table>

        <h2>üé™ Binary Semaphores - Event Signaling</h2>

        <div class="concept-box">
            <h3>Think of It as a Flag</h3>
            <p>A binary semaphore has only two states: <strong>0</strong> (not available) or <strong>1</strong> (available).</p>
            <ul>
                <li><strong>Give()</strong> ‚Üí Raises the flag (sets to 1)</li>
                <li><strong>Take()</strong> ‚Üí Lowers the flag (sets to 0) and proceeds</li>
                <li>If flag is down (0), Take() blocks until someone Give()s</li>
            </ul>
        </div>

        <div class="mermaid">
sequenceDiagram
    participant Signaler as Signaler Task
    participant Sem as Binary Semaphore
    participant Waiter as Waiter Task
    
    Note over Waiter: xSemaphoreTake()<br/>BLOCKS (waiting...)
    Signaler->>Sem: xSemaphoreGive()<br/>(Raise flag)
    Note over Sem: Count: 0 ‚Üí 1
    Sem->>Waiter: OS wakes task
    Note over Waiter: Take succeeds!<br/>Do work...
    Note over Sem: Count: 1 ‚Üí 0
        </div>

        <div class="code-block"><span class="comment">// Create binary semaphore</span>
<span class="type">SemaphoreHandle_t</span> eventSemaphore;
eventSemaphore = <span class="function">xSemaphoreCreateBinary</span>();

<span class="comment">// Signaler Task (raises flag)</span>
<span class="keyword">void</span> <span class="function">signalerTask</span>(<span class="keyword">void</span> *pvParameter) {
    <span class="keyword">while</span>(<span class="number">1</span>) {
        <span class="comment">// Wait for some event...</span>
        <span class="function">vTaskDelay</span>(<span class="function">pdMS_TO_TICKS</span>(<span class="number">2000</span>));
        
        <span class="function">ESP_LOGI</span>(<span class="string">"Signaler"</span>, <span class="string">"Signaling event!"</span>);
        <span class="function">xSemaphoreGive</span>(eventSemaphore);  <span class="comment">// Raise flag</span>
    }
}

<span class="comment">// Waiter Task (waits for flag)</span>
<span class="keyword">void</span> <span class="function">waiterTask</span>(<span class="keyword">void</span> *pvParameter) {
    <span class="keyword">while</span>(<span class="number">1</span>) {
        <span class="comment">// Block until someone signals</span>
        <span class="function">xSemaphoreTake</span>(eventSemaphore, portMAX_DELAY);
        
        <span class="function">ESP_LOGI</span>(<span class="string">"Waiter"</span>, <span class="string">"Got signal! Processing..."</span>);
        <span class="comment">// Do work here...</span>
    }
}</div>

        <div class="success-box">
            <h3>‚úÖ Why Semaphores are Efficient</h3>
            <p><strong>Blocking = Zero CPU Usage!</strong></p>
            <p>When a task calls <code>xSemaphoreTake()</code> and the semaphore isn't available:</p>
            <ul>
                <li>Task enters <strong>BLOCKED</strong> state (not consuming CPU)</li>
                <li>OS scheduler skips this task completely</li>
                <li>Other tasks run normally</li>
                <li>When <code>Give()</code> is called, OS immediately wakes the waiting task</li>
            </ul>
            <p><strong>Compare to polling:</strong> <code>while(!flag) { vTaskDelay(10); }</code> ‚Üê Still wastes CPU checking!</p>
        </div>

        <h2>üîê Mutexes - Resource Protection</h2>

        <div class="concept-box">
            <h3>Mutual Exclusion Lock</h3>
            <p>A mutex ensures <strong>only ONE task</strong> can access a shared resource at a time.</p>
            <ul>
                <li><strong>Take()</strong> ‚Üí Lock (acquire mutex) - "I'm using this resource"</li>
                <li><strong>Critical Section</strong> ‚Üí Do your work with the shared resource</li>
                <li><strong>Give()</strong> ‚Üí Unlock (release mutex) - "I'm done, next task can go"</li>
            </ul>
        </div>

        <div class="danger-box">
            <h3>‚ö†Ô∏è Race Condition Example</h3>
            <p>What seems like one operation is actually THREE:</p>
            <div class="code-block"><span class="type">int</span> counter = <span class="number">0</span>;

counter++;  <span class="comment">// Looks atomic, but it's NOT!</span>

<span class="comment">// Actually compiled to:</span>
<span class="comment">// 1. Read counter from memory ‚Üí register</span>
<span class="comment">// 2. Add 1 to register</span>
<span class="comment">// 3. Write register ‚Üí memory</span></div>

            <h3>What Goes Wrong:</h3>
            <div class="code-block"><span class="comment">// Both tasks start with counter = 5</span>

<span class="comment">Task A: Read counter=5 ‚Üí Add 1 ‚Üí (context switch!)</span>
<span class="comment">Task B: Read counter=5 ‚Üí Add 1 ‚Üí Write 6</span>
<span class="comment">Task A: (resume) ‚Üí Write 6  ‚Üê Lost Task B's increment!</span>

<span class="comment">Result: counter = 6 (should be 7)</span></div>
        </div>

        <div class="comparison">
            <div class="bad">
                <h3>‚ùå Without Mutex</h3>
                <div class="code-block"><span class="type">int</span> shared_counter = <span class="number">0</span>;

<span class="keyword">void</span> <span class="function">task</span>(<span class="keyword">void</span> *p) {
    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i<<span class="number">1000</span>; i++) {
        shared_counter++;
        <span class="comment">// Race condition!</span>
    }
}</div>
                <p><strong>Result:</strong> Final count might be 1847, 1923, 1956... <strong>Never 2000!</strong></p>
            </div>
            
            <div class="good">
                <h3>‚úÖ With Mutex</h3>
                <div class="code-block"><span class="type">int</span> shared_counter = <span class="number">0</span>;
<span class="type">SemaphoreHandle_t</span> mutex;

<span class="keyword">void</span> <span class="function">task</span>(<span class="keyword">void</span> *p) {
    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i<<span class="number">1000</span>; i++) {
        <span class="function">xSemaphoreTake</span>(mutex, portMAX_DELAY);
        shared_counter++;  <span class="comment">// Protected!</span>
        <span class="function">xSemaphoreGive</span>(mutex);
    }
}</div>
                <p><strong>Result:</strong> Final count is <strong>always 2000!</strong></p>
            </div>
        </div>

        <div class="mermaid">
sequenceDiagram
    participant A as Task A
    participant M as Mutex
    participant B as Task B
    
    A->>M: xSemaphoreTake()
    Note over M: Locked by A
    Note over A: counter++<br/>(Critical section)
    B->>M: xSemaphoreTake()
    Note over B: BLOCKS<br/>(waiting for mutex)
    A->>M: xSemaphoreGive()
    Note over M: Unlocked
    M->>B: OS wakes Task B
    Note over B: counter++<br/>(Now safe!)
    B->>M: xSemaphoreGive()
        </div>

        <h2>‚ö° The volatile Keyword - Common Misconception</h2>

        <div class="warning-box">
            <h3>‚ùå volatile Does NOT Fix Race Conditions!</h3>
            <div class="code-block"><span class="keyword">volatile</span> <span class="type">int</span> counter = <span class="number">0</span>;

counter++;  <span class="comment">// Still NOT atomic!</span>
            <span class="comment">// Still has race condition!</span></div>

            <h3>What volatile Actually Does:</h3>
            <ul>
                <li>Tells compiler: "This variable can change outside this code's control"</li>
                <li>Prevents compiler from caching value in registers</li>
                <li>Forces actual memory read/write every time</li>
                <li><strong>Does NOT</strong> make operations atomic</li>
                <li><strong>Does NOT</strong> prevent race conditions</li>
                <li><strong>Does NOT</strong> replace mutex</li>
            </ul>
        </div>

        <div class="concept-box">
            <h3>‚úÖ When to Use volatile</h3>
            <table>
                <tr>
                    <th>Use Case</th>
                    <th>Why</th>
                    <th>Example</th>
                </tr>
                <tr>
                    <td>Hardware registers</td>
                    <td>Memory-mapped I/O can change any time</td>
                    <td><code>volatile uint32_t *GPIO_REG</code></td>
                </tr>
                <tr>
                    <td>ISR-modified variables</td>
                    <td>Interrupt can change it mid-execution</td>
                    <td><code>volatile bool button_pressed</code></td>
                </tr>
                <tr>
                    <td>DMA buffers</td>
                    <td>Hardware writes to memory directly</td>
                    <td><code>volatile uint8_t dma_buffer[256]</code></td>
                </tr>
                <tr>
                    <td>Multi-core shared flags</td>
                    <td>Other core can change it</td>
                    <td><code>volatile int core_status</code></td>
                </tr>
            </table>

            <h3>‚ùå When NOT to Use volatile</h3>
            <ul>
                <li>Task-shared variables (use mutex instead!)</li>
                <li>Queue/semaphore-protected data</li>
                <li>Local variables in functions</li>
                <li>As a "magic fix" for threading bugs</li>
            </ul>
        </div>

        <h2>üéØ Semaphore vs Mutex - When to Use What?</h2>

        <div class="vs-box">
            <div>
                <h3>Use Binary Semaphore When:</h3>
                <ul>
                    <li>Signaling events between tasks</li>
                    <li>ISR ‚Üí Task communication</li>
                    <li>"Something happened, go process it"</li>
                    <li>Task A triggers, Task B responds</li>
                    <li>Different tasks Give and Take</li>
                </ul>
                <p><strong>Pattern:</strong> Coordination</p>
            </div>
            
            <div class="vs-text">VS</div>
            
            <div>
                <h3>Use Mutex When:</h3>
                <ul>
                    <li>Protecting shared data/resources</li>
                    <li>Multiple tasks access same variable</li>
                    <li>Shared hardware (UART, SPI, I2C)</li>
                    <li>Critical sections</li>
                    <li>Same task Takes and Gives</li>
                </ul>
                <p><strong>Pattern:</strong> Protection</p>
            </div>
        </div>

        <div class="code-block"><span class="comment">// SEMAPHORE: Task A signals, Task B waits</span>
<span class="function">TaskA</span>: <span class="function">xSemaphoreGive</span>(semaphore);      <span class="comment">// Raise flag</span>
<span class="function">TaskB</span>: <span class="function">xSemaphoreTake</span>(semaphore, ...); <span class="comment">// Wait for flag</span>

<span class="comment">// MUTEX: Same task locks and unlocks</span>
<span class="function">TaskA</span>: <span class="function">xSemaphoreTake</span>(mutex, ...);      <span class="comment">// Lock</span>
<span class="function">TaskA</span>: <span class="comment">/* access shared resource */</span>
<span class="function">TaskA</span>: <span class="function">xSemaphoreGive</span>(mutex);           <span class="comment">// Unlock</span></div>

        <h2>üß™ Real-World Examples</h2>

        <div class="concept-box">
            <h3>Example 1: Button Handler (Semaphore)</h3>
            <div class="code-block"><span class="type">SemaphoreHandle_t</span> buttonSemaphore;

<span class="comment">// ISR (interrupt service routine)</span>
<span class="keyword">void</span> IRAM_ATTR <span class="function">button_isr</span>() {
    <span class="comment">// Minimal work in ISR - just signal!</span>
    <span class="type">BaseType_t</span> xHigherPriorityTaskWoken = pdFALSE;
    <span class="function">xSemaphoreGiveFromISR</span>(buttonSemaphore, &xHigherPriorityTaskWoken);
    <span class="keyword">if</span>(xHigherPriorityTaskWoken) {
        <span class="function">portYIELD_FROM_ISR</span>();
    }
}

<span class="comment">// Button handler task</span>
<span class="keyword">void</span> <span class="function">buttonTask</span>(<span class="keyword">void</span> *p) {
    <span class="keyword">while</span>(<span class="number">1</span>) {
        <span class="comment">// Wait for button press</span>
        <span class="function">xSemaphoreTake</span>(buttonSemaphore, portMAX_DELAY);
        
        <span class="comment">// Heavy processing here (logging, LED toggle, etc.)</span>
        <span class="function">ESP_LOGI</span>(<span class="string">"Button"</span>, <span class="string">"Button pressed! Doing work..."</span>);
        <span class="function">toggle_led</span>();
    }
}</div>
            <p><strong>Why semaphore?</strong> ISR signals event, task does heavy work.</p>
        </div>

        <div class="concept-box">
            <h3>Example 2: Shared UART (Mutex)</h3>
            <div class="code-block"><span class="type">SemaphoreHandle_t</span> uartMutex;

<span class="keyword">void</span> <span class="function">safe_uart_print</span>(<span class="keyword">const char</span> *msg) {
    <span class="function">xSemaphoreTake</span>(uartMutex, portMAX_DELAY);  <span class="comment">// Lock UART</span>
    
    <span class="function">uart_write_bytes</span>(UART_NUM_0, msg, <span class="function">strlen</span>(msg));
    
    <span class="function">xSemaphoreGive</span>(uartMutex);  <span class="comment">// Unlock UART</span>
}

<span class="comment">// Multiple tasks can safely print</span>
<span class="function">Task1</span>: <span class="function">safe_uart_print</span>(<span class="string">"Task 1 message\n"</span>);
<span class="function">Task2</span>: <span class="function">safe_uart_print</span>(<span class="string">"Task 2 message\n"</span>);
<span class="comment">// No garbled output!</span></div>
            <p><strong>Why mutex?</strong> Multiple tasks need exclusive access to one resource.</p>
        </div>

        <div class="concept-box">
            <h3>Example 3: Counting Semaphore (Resource Pool)</h3>
            <div class="code-block"><span class="comment">// 3 available SPI devices</span>
<span class="type">SemaphoreHandle_t</span> spiPool = <span class="function">xSemaphoreCreateCounting</span>(<span class="number">3</span>, <span class="number">3</span>);

<span class="keyword">void</span> <span class="function">use_spi_device</span>() {
    <span class="comment">// Try to allocate one device</span>
    <span class="keyword">if</span>(<span class="function">xSemaphoreTake</span>(spiPool, <span class="function">pdMS_TO_TICKS</span>(<span class="number">1000</span>))) {
        <span class="comment">// Got a device! Use it...</span>
        <span class="function">spi_transaction</span>();
        
        <span class="comment">// Return device to pool</span>
        <span class="function">xSemaphoreGive</span>(spiPool);
    } <span class="keyword">else</span> {
        <span class="function">ESP_LOGW</span>(<span class="string">"SPI"</span>, <span class="string">"All devices busy!"</span>);
    }
}</div>
            <p><strong>Why counting semaphore?</strong> Track limited pool of identical resources.</p>
        </div>

        <h2>ü§î Critical Thinking Questions</h2>

        <div class="question">
            <strong>Q1: Your exercise shows final count < 2000 without mutex. Why doesn't it always show the SAME wrong number?</strong>
            <div class="answer">
                <strong>Answer:</strong><br>
                Race conditions are <strong>non-deterministic</strong> (unpredictable)!<br><br>
                <strong>It depends on:</strong><br>
                ‚Ä¢ When exactly the context switch happens<br>
                ‚Ä¢ Which task gets interrupted mid-operation<br>
                ‚Ä¢ FreeRTOS scheduler timing (affected by system load)<br>
                ‚Ä¢ Number of times both tasks are in critical section simultaneously<br><br>
                <strong>You might see:</strong> 1847, 1923, 1956, 1892... different every run!<br>
                <strong>This is what makes race conditions so dangerous</strong> - they're hard to reproduce and debug.
            </div>
        </div>

        <div class="question">
            <strong>Q2: What happens if Task A holds a mutex and then gets suspended (deleted, blocked forever, crashes)?</strong>
            <div class="answer">
                <strong>Answer:</strong><br>
                <strong>Deadlock!</strong> Task B will block forever on <code>xSemaphoreTake()</code>.<br><br>
                <strong>Prevention strategies:</strong><br>
                1. Use timeouts: <code>xSemaphoreTake(mutex, pdMS_TO_TICKS(5000))</code><br>
                2. Always pair Take/Give in same code path<br>
                3. Use watchdog timers to detect deadlocks<br>
                4. Be careful with nested mutexes (can cause circular deadlock)<br>
                5. Keep critical sections SHORT - don't delay or block inside<br><br>
                <strong>FreeRTOS mutexes have priority inheritance</strong> to help prevent priority inversion deadlocks.
            </div>
        </div>

        <div class="question">
            <strong>Q3: Can you use the same mutex to protect multiple different variables?</strong>
            <div class="answer">
                <strong>Answer:</strong><br>
                <strong>Yes, but be careful!</strong><br><br>
                <strong>‚úÖ Good:</strong> Protect related variables that are always accessed together<br>
                <code>xSemaphoreTake(mutex);</code><br>
                <code>x = new_x; y = new_y;</code> // Related coordinates<br>
                <code>xSemaphoreGive(mutex);</code><br><br>
                <strong>‚ùå Bad:</strong> Protect unrelated variables with same mutex<br>
                <code>xSemaphoreTake(globalMutex);</code><br>
                <code>button_count++;</code> // Unrelated!<br>
                <code>xSemaphoreGive(globalMutex);</code><br><br>
                <strong>Problem:</strong> All tasks contend for same mutex even when accessing different data!<br>
                <strong>Better:</strong> Use separate mutexes for independent resources (better parallelism).
            </div>
        </div>

        <div class="question">
            <strong>Q4: What's the performance cost of using mutex for every increment?</strong>
            <div class="answer">
                <strong>Answer:</strong><br>
                <strong>Mutex overhead:</strong><br>
                ‚Ä¢ Take: ~5-20 CPU cycles (if not contended)<br>
                ‚Ä¢ Give: ~5-20 CPU cycles<br>
                ‚Ä¢ Context switch: ~hundreds of cycles (if mutex blocked)<br><br>
                <strong>Trade-off:</strong><br>
                Correctness > Speed! Better slow and right than fast and wrong.<br><br>
                <strong>Optimization strategies:</strong><br>
                1. Batch operations (lock once, do 10 things, unlock)<br>
                2. Use lock-free atomic operations (advanced)<br>
                3. Reduce contention (per-task counters, merge later)<br>
                4. Profile first - don't optimize prematurely!<br><br>
                <strong>On ESP32:</strong> Mutex overhead is negligible for most applications.
            </div>
        </div>

        <h2>üìã Best Practices Summary</h2>

        <div class="success-box">
            <h3>‚úÖ DO:</h3>
            <ul>
                <li>Use semaphores for task coordination and signaling</li>
                <li>Use mutexes for protecting shared resources</li>
                <li>Always pair Take/Give in same function</li>
                <li>Keep critical sections SHORT (no delays inside!)</li>
                <li>Use timeouts to prevent deadlocks</li>
                <li>Check return values (Take can fail!)</li>
                <li>Use volatile for hardware registers and ISR variables</li>
            </ul>
        </div>

        <div class="warning-box">
            <h3>‚ùå DON'T:</h3>
            <ul>
                <li>Use volatile as a "fix" for race conditions</li>
                <li>Call vTaskDelay() inside mutex-protected sections</li>
                <li>Block inside critical sections (defeats purpose!)</li>
                <li>Nest mutexes unnecessarily (deadlock risk)</li>
                <li>Share one mutex for unrelated resources</li>
                <li>Forget to Give after Take (deadlock!)</li>
                <li>Use global variables without protection</li>
            </ul>
        </div>

        <h2>üéì What You've Mastered</h2>

        <div class="concept-box">
            <ul>
                <li>‚úÖ <strong>Binary semaphores</strong> - Event signaling pattern</li>
                <li>‚úÖ <strong>Mutexes</strong> - Critical section protection</li>
                <li>‚úÖ <strong>Race conditions</strong> - Understanding the problem</li>
                <li>‚úÖ <strong>Non-atomic operations</strong> - Why counter++ fails</li>
                <li>‚úÖ <strong>volatile keyword</strong> - What it does and doesn't do</li>
                <li>‚úÖ <strong>Guard pattern</strong> - Take ‚Üí Work ‚Üí Give</li>
                <li>‚úÖ <strong>ISR deferral</strong> - ISR signals, task does work</li>
            </ul>
        </div>

        <div class="success-box">
            <h3>üöÄ Next Steps: Days 6-7 - Multi-Task LED Controller Project</h3>
            <p>Time to build your first real embedded project!</p>
            <ul>
                <li>Combine tasks, queues, semaphores, and mutexes</li>
                <li>Control 4 LEDs with multiple patterns</li>
                <li>Button input handling</li>
                <li>Serial command interface</li>
                <li>Real-time coordination between subsystems</li>
            </ul>
            <p><strong>This is where it all comes together!</strong></p>
        </div>
    </div>

    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            },
            sequence: {
                useMaxWidth: true,
                wrap: true
            }
        });
    </script>
</body>
</html>