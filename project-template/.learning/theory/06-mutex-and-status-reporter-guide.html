<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mutex & Status Reporter Implementation Guide - ESP32 Tutorial</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 50px;
        }

        .section-title {
            font-size: 2em;
            color: #1e3c72;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border-left: 5px solid #2196f3;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h3 {
            color: #1565c0;
            margin-bottom: 10px;
        }

        .warning-box {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            border-left: 5px solid #ff9800;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning-box h3 {
            color: #e65100;
            margin-bottom: 10px;
        }

        .success-box {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-left: 5px solid #4caf50;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .success-box h3 {
            color: #1b5e20;
            margin-bottom: 10px;
        }

        .danger-box {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            border-left: 5px solid #dc3545;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .danger-box h3 {
            color: #c62828;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        .danger-box h3::before {
            content: "‚ö†Ô∏è";
            margin-right: 10px;
            font-size: 1.2em;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            font-family: 'Courier New', Consolas, Monaco, monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow-x: auto;
            margin: 15px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .code-label {
            background: #1e3c72;
            color: white;
            padding: 8px 15px;
            border-radius: 5px 5px 0 0;
            font-weight: bold;
            display: inline-block;
            margin-top: 20px;
        }

        .step-box {
            background: white;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .step-number {
            display: inline-block;
            background: #667eea;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            text-align: center;
            line-height: 40px;
            font-size: 1.5em;
            font-weight: bold;
            margin-right: 15px;
        }

        .step-title {
            display: inline-block;
            font-size: 1.3em;
            color: #1e3c72;
            font-weight: bold;
        }

        .mermaid-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .keyword {
            color: #c678dd;
            font-weight: bold;
        }

        .function {
            color: #61afef;
        }

        .string {
            color: #98c379;
        }

        .comment {
            color: #5c6370;
            font-style: italic;
        }

        ul, ol {
            margin-left: 30px;
            margin-top: 10px;
        }

        li {
            margin: 8px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        table th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
        }

        table td {
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
        }

        table tr:hover {
            background: #f5f5f5;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-item {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .comparison-item.bad {
            border: 2px solid #dc3545;
        }

        .comparison-item.good {
            border: 2px solid #4caf50;
        }

        .checklist {
            list-style: none;
            margin-left: 0;
        }

        .checklist li {
            padding: 10px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }

        .checklist li::before {
            content: "‚òê ";
            font-size: 1.2em;
            margin-right: 10px;
            color: #667eea;
        }

        @media (max-width: 768px) {
            .comparison-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê Mutex & Status Reporter Guide</h1>
            <p class="subtitle">Professional Approach to Task Synchronization in FreeRTOS</p>
        </div>

        <div class="content">
            <!-- What is a Mutex? -->
            <div class="section">
                <h2 class="section-title">ü§î What is a Mutex?</h2>

                <div class="info-box">
                    <h3>Mutex = Mutual Exclusion Lock</h3>
                    <p><strong>Think of it as a bathroom key:</strong></p>
                    <ul>
                        <li>Only one person can hold the key at a time</li>
                        <li>Others must wait until the key is returned</li>
                        <li>No one can enter without the key</li>
                    </ul>
                    
                    <p style="margin-top: 15px;"><strong>In programming:</strong></p>
                    <ul>
                        <li>Only one task can "own" the mutex at a time</li>
                        <li>Other tasks block (wait) if mutex is taken</li>
                        <li>Protects shared resources from simultaneous access</li>
                    </ul>
                </div>

                <div class="mermaid-container">
                    <div class="mermaid">
                        sequenceDiagram
                            participant T1 as Task1
                            participant M as Mutex
                            participant R as UART
                            participant T2 as Task2
                            
                            T1->>M: xSemaphoreTake()
                            M->>T1: Granted
                            T1->>R: ESP_LOGI Hello
                            
                            Note over T2: Wants to print
                            T2->>M: xSemaphoreTake()
                            M->>T2: BLOCKED wait
                            
                            Note over T1: Finishes printing
                            T1->>M: xSemaphoreGive()
                            M->>M: Unlocked
                            M->>T2: Granted
                            T2->>R: ESP_LOGI World
                            T2->>M: xSemaphoreGive()
                    </div>
                    </div>
                </div>

                <div class="warning-box">
                    <h3>Why Do We Need Mutex for UART?</h3>
                    <p><strong>Without Mutex (Race Condition):</strong></p>
                    <div class="code-block">Task 1: ESP_LOGI("Pattern: 2");
Task 2: ESP_LOGI("Speed: 500");

// Output gets mixed:
PattSpeed: ern: 2500</div>

                    <p style="margin-top: 15px;"><strong>With Mutex (Protected):</strong></p>
                    <div class="code-block">Task 1: Take mutex ‚Üí Print "Pattern: 2" ‚Üí Give mutex
Task 2: Wait ‚Üí Take mutex ‚Üí Print "Speed: 500" ‚Üí Give mutex

// Output is clean:
Pattern: 2
Speed: 500</div>
                </div>
            </div>

            <!-- The Problem We're Solving -->
            <div class="section">
                <h2 class="section-title">üéØ The Problem We're Solving</h2>

                <div class="danger-box">
                    <h3>Current Issue: Multiple Tasks Print Simultaneously</h3>
                    <p>You have (or will have) multiple tasks calling <code>ESP_LOGI()</code>:</p>
                    <ol>
                        <li><strong>Serial Task</strong> - Prints when commands received</li>
                        <li><strong>Pattern Sequencer</strong> - Prints pattern changes</li>
                        <li><strong>Button Task</strong> - Prints button presses</li>
                        <li><strong>Status Reporter</strong> (to be added) - Prints status every 5 seconds</li>
                    </ol>
                    
                    <p style="margin-top: 15px;"><strong>Result:</strong> UART output gets garbled when tasks print at the same time!</p>
                </div>

                <div class="comparison-grid">
                    <div class="comparison-item bad">
                        <h4>‚ùå Without Mutex Protection</h4>
                        <div class="code-block" style="font-size: 12px;">Serial: Pattern ChangeButton: PRESSEDd
StatStautsu: s: reCuqruresntte pda
ttPerant:te 2rn: 1
SpSepede: ed5:0 04m0s0ms</div>
                        <p style="color: #dc3545; margin-top: 10px;"><strong>Unreadable chaos!</strong></p>
                    </div>
                    
                    <div class="comparison-item good">
                        <h4>‚úÖ With Mutex Protection</h4>
                        <div class="code-block" style="font-size: 12px;">Serial: Pattern Changed to 2
Button: PRESSED
Status: Current pattern: 1
Pattern: Speed 400ms
Status requested</div>
                        <p style="color: #4caf50; margin-top: 10px;"><strong>Clean and readable!</strong></p>
                    </div>
                </div>
            </div>

            <!-- Step-by-Step Implementation -->
            <div class="section">
                <h2 class="section-title">üõ†Ô∏è Step-by-Step Implementation</h2>

                <!-- STEP 1 -->
                <div class="step-box">
                    <span class="step-number">1</span>
                    <span class="step-title">Declare Global Mutex Variable</span>
                    
                    <div class="info-box" style="margin-top: 20px;">
                        <p>Add this with your other global variables (after QueueHandle_t declarations):</p>
                    </div>

                    <div class="code-label">üìç Location: After line 24 (with other globals)</div>
                    <div class="code-block">QueueHandle_t g_patternQueue = NULL;
QueueHandle_t g_speedQueue = NULL;
g_serialHandle sHandle;

<span class="comment">// Add this:</span>
SemaphoreHandle_t g_uartMutex = NULL;  <span class="comment">// Protects UART/serial output</span>

char g_commandBuffer[32] = {0};</div>

                    <div class="info-box">
                        <h4>What is SemaphoreHandle_t?</h4>
                        <ul>
                            <li>FreeRTOS type for semaphore/mutex handles</li>
                            <li>It's a pointer (opaque handle) to the mutex object</li>
                            <li>Initialize to <code>NULL</code> before creation</li>
                        </ul>
                    </div>
                </div>

                <!-- STEP 2 -->
                <div class="step-box">
                    <span class="step-number">2</span>
                    <span class="step-title">Create Mutex in app_main()</span>
                    
                    <div class="info-box" style="margin-top: 20px;">
                        <p>Create the mutex during initialization, right after creating queues:</p>
                    </div>

                    <div class="code-label">üìç Location: In app_main(), after queue creation</div>
                    <div class="code-block">g_patternQueue = xQueueCreate(10, sizeof(int));
g_speedQueue = xQueueCreate(10, sizeof(int));
sHandle.patternQHandle = g_patternQueue;
sHandle.speedQHandle = g_speedQueue;

<span class="comment">// Add this:</span>
g_uartMutex = xSemaphoreCreateMutex();
<span class="keyword">if</span> (g_uartMutex == NULL) {
    ESP_LOGE(TAG, <span class="string">"Failed to create UART mutex!"</span>);
    <span class="keyword">return</span>;  <span class="comment">// Cannot continue without mutex</span>
}</div>

                    <div class="info-box">
                        <h4>xSemaphoreCreateMutex() Explained</h4>
                        <ul>
                            <li><strong>Returns:</strong> Handle to created mutex (or NULL if failed)</li>
                            <li><strong>Initial state:</strong> Unlocked (available)</li>
                            <li><strong>Always check:</strong> Verify it's not NULL before using</li>
                        </ul>
                    </div>
                </div>

                <!-- STEP 3 -->
                <div class="step-box">
                    <span class="step-number">3</span>
                    <span class="step-title">Protect Serial Task Prints</span>
                    
                    <div class="info-box" style="margin-top: 20px;">
                        <p>Wrap ALL ESP_LOGI() calls with mutex take/give:</p>
                    </div>

                    <div class="code-label">üìç Location: serialTask() function</div>
                    <div class="code-block"><span class="keyword">void</span> serialTask(<span class="keyword">void</span> *pvParameter)
{
    g_serialHandle *handles = (g_serialHandle *)pvParameter;
    <span class="keyword">char</span> rxtext[50] = {0};
    <span class="keyword">uint16_t</span> rxdPattern = 0;
    <span class="keyword">uint16_t</span> rxdSpeed = 0;

    <span class="comment">// Take mutex before printing</span>
    xSemaphoreTake(g_uartMutex, portMAX_DELAY);
    ESP_LOGI(<span class="string">"SERIALTASK"</span>, <span class="string">"Entered Serial Task"</span>);
    xSemaphoreGive(g_uartMutex);  <span class="comment">// Release immediately</span>

    <span class="keyword">while</span> (1)
    {
        <span class="keyword">if</span> (fgets(rxtext, <span class="keyword">sizeof</span>(rxtext), stdin) != NULL)
        {
            <span class="comment">// Take mutex, print, give back</span>
            xSemaphoreTake(g_uartMutex, portMAX_DELAY);
            ESP_LOGI(<span class="string">"SERIALTASK"</span>, <span class="string">"Received: %s"</span>, rxtext);
            xSemaphoreGive(g_uartMutex);

            <span class="keyword">char</span> cmd[20] = {0};
            <span class="keyword">int</span> value = 0;

            <span class="keyword">if</span> (sscanf(rxtext, <span class="string">"%s %d"</span>, cmd, &value) >= 1)
            {
                <span class="keyword">if</span> (strcmp(cmd, <span class="string">"pattern"</span>) == 0 && value >= 0 && value <= 3)
                {
                    rxdPattern = (<span class="keyword">uint16_t</span>)value;
                    xQueueSend(handles->patternQHandle, &rxdPattern, 0);
                    
                    <span class="comment">// Protect this print too</span>
                    xSemaphoreTake(g_uartMutex, portMAX_DELAY);
                    ESP_LOGI(<span class="string">"SERIALTASK"</span>, <span class="string">"Pattern changed to: %d"</span>, rxdPattern);
                    xSemaphoreGive(g_uartMutex);
                }
                <span class="keyword">else if</span> (strcmp(cmd, <span class="string">"speed"</span>) == 0 && value >= 50 && value <= 1000)
                {
                    rxdSpeed = (<span class="keyword">uint16_t</span>)value;
                    xQueueSend(handles->speedQHandle, &rxdSpeed, 0);
                    
                    xSemaphoreTake(g_uartMutex, portMAX_DELAY);
                    ESP_LOGI(<span class="string">"SERIALTASK"</span>, <span class="string">"Speed changed to: %d"</span>, rxdSpeed);
                    xSemaphoreGive(g_uartMutex);
                }
                <span class="keyword">else if</span> (strcmp(cmd, <span class="string">"status"</span>) == 0)
                {
                    <span class="comment">// Trigger status reporter (we'll add this semaphore next)</span>
                    xSemaphoreTake(g_uartMutex, portMAX_DELAY);
                    ESP_LOGI(<span class="string">"SERIALTASK"</span>, <span class="string">"Status requested"</span>);
                    xSemaphoreGive(g_uartMutex);
                }
            }
        }

        vTaskDelay(pdMS_TO_TICKS(100));
    }
}</div>

                    <div class="danger-box">
                        <h3>CRITICAL RULE: Always Pair Take/Give</h3>
                        <ul>
                            <li>Every <code>xSemaphoreTake()</code> MUST have matching <code>xSemaphoreGive()</code></li>
                            <li>Give the mutex as soon as possible (minimize lock time)</li>
                            <li>NEVER hold mutex while calling <code>vTaskDelay()</code> - blocks everyone!</li>
                        </ul>
                    </div>
                </div>

                <!-- STEP 4 -->
                <div class="step-box">
                    <span class="step-number">4</span>
                    <span class="step-title">Add Status Trigger Semaphore</span>
                    
                    <div class="info-box" style="margin-top: 20px;">
                        <p>Status Reporter needs TWO synchronization objects:</p>
                        <ol>
                            <li><strong>UART Mutex</strong> - To protect printing (shared with other tasks)</li>
                            <li><strong>Binary Semaphore</strong> - To trigger immediate status print on command</li>
                        </ol>
                    </div>

                    <div class="code-label">üìç Add another global semaphore</div>
                    <div class="code-block">SemaphoreHandle_t g_uartMutex = NULL;
<span class="comment">// Add this:</span>
SemaphoreHandle_t g_statusTrigger = NULL;  <span class="comment">// Signals status reporter to print now</span></div>

                    <div class="code-label">üìç Create it in app_main()</div>
                    <div class="code-block">g_uartMutex = xSemaphoreCreateMutex();
<span class="keyword">if</span> (g_uartMutex == NULL) { <span class="comment">/* error handling */</span> }

<span class="comment">// Add this:</span>
g_statusTrigger = xSemaphoreCreateBinary();
<span class="keyword">if</span> (g_statusTrigger == NULL) {
    ESP_LOGE(TAG, <span class="string">"Failed to create status trigger semaphore!"</span>);
    <span class="keyword">return</span>;
}</div>
                </div>

                <!-- STEP 5 -->
                <div class="step-box">
                    <span class="step-number">5</span>
                    <span class="step-title">Implement Status Reporter Task</span>
                    
                    <div class="info-box" style="margin-top: 20px;">
                        <p>This task prints system status every 5 seconds AND immediately when triggered:</p>
                    </div>

                    <div class="code-label">üìç Add this function before app_main()</div>
                    <div class="code-block"><span class="keyword">void</span> statusReporter(<span class="keyword">void</span> *pvParameter)
{
    g_serialHandle *handles = (g_serialHandle *)pvParameter;
    <span class="keyword">uint16_t</span> currentPattern = 0;
    <span class="keyword">uint16_t</span> currentSpeed = g_speed_ms;
    
    <span class="keyword">while</span> (1)
    {
        <span class="comment">// Wait 5 seconds OR until triggered by semaphore</span>
        <span class="keyword">if</span> (xSemaphoreTake(g_statusTrigger, pdMS_TO_TICKS(5000)) == pdTRUE) {
            <span class="comment">// Triggered by "status" command - print immediately</span>
        } <span class="keyword">else</span> {
            <span class="comment">// Timeout - 5 seconds elapsed, print periodic status</span>
        }
        
        <span class="comment">// Peek at current values (you'd need to share these properly)</span>
        currentSpeed = g_speed_ms;
        
        <span class="comment">// TAKE MUTEX before printing multiple lines</span>
        xSemaphoreTake(g_uartMutex, portMAX_DELAY);
        
        ESP_LOGI(<span class="string">"STATUS"</span>, <span class="string">"======== SYSTEM STATUS ========"</span>);
        ESP_LOGI(<span class="string">"STATUS"</span>, <span class="string">"Current Speed: %d ms"</span>, currentSpeed);
        ESP_LOGI(<span class="string">"STATUS"</span>, <span class="string">"Uptime: %llu sec"</span>, esp_timer_get_time() / 1000000);
        ESP_LOGI(<span class="string">"STATUS"</span>, <span class="string">"Free Heap: %d bytes"</span>, esp_get_free_heap_size());
        ESP_LOGI(<span class="string">"STATUS"</span>, <span class="string">"=============================="</span>);
        
        <span class="comment">// GIVE MUTEX after all prints done</span>
        xSemaphoreGive(g_uartMutex);
    }
}</div>

                    <div class="info-box">
                        <h4>How This Works:</h4>
                        <ol>
                            <li><code>xSemaphoreTake(g_statusTrigger, 5000ms)</code> - Wait up to 5 seconds</li>
                            <li>If semaphore given ‚Üí Print immediately (triggered by command)</li>
                            <li>If timeout ‚Üí Print anyway (periodic 5-second report)</li>
                            <li>Take UART mutex once for ALL prints (more efficient)</li>
                            <li>Release mutex after done</li>
                        </ol>
                    </div>
                </div>

                <!-- STEP 6 -->
                <div class="step-box">
                    <span class="step-number">6</span>
                    <span class="step-title">Trigger Status from Serial Task</span>
                    
                    <div class="code-label">üìç Update status command handler in serialTask()</div>
                    <div class="code-block"><span class="keyword">else if</span> (strcmp(cmd, <span class="string">"status"</span>) == 0)
{
    <span class="comment">// Signal status reporter to print NOW (don't wait 5 seconds)</span>
    xSemaphoreGive(g_statusTrigger);
    
    <span class="comment">// Optional: Acknowledge command received</span>
    xSemaphoreTake(g_uartMutex, portMAX_DELAY);
    ESP_LOGI(<span class="string">"SERIALTASK"</span>, <span class="string">"Status report triggered"</span>);
    xSemaphoreGive(g_uartMutex);
}</div>
                </div>

                <!-- STEP 7 -->
                <div class="step-box">
                    <span class="step-number">7</span>
                    <span class="step-title">Create Status Reporter Task</span>
                    
                    <div class="code-label">üìç Add in app_main() with other task creations</div>
                    <div class="code-block">xTaskCreate(patternSequencer, <span class="string">"pattern"</span>, 2048, &sHandle, 3, NULL);
xTaskCreate(buttonTask, <span class="string">"buttonTask"</span>, 2048, g_patternQueue, 5, NULL);
xTaskCreate(serialTask, <span class="string">"SerialTask"</span>, 4096, &sHandle, 2, NULL);

<span class="comment">// Add this:</span>
xTaskCreate(statusReporter, <span class="string">"StatusTask"</span>, 3072, &sHandle, 1, NULL);
<span class="comment">//                                                    ^^ Priority 1 (lowest)</span></div>

                    <div class="info-box">
                        <h4>Why Priority 1 (Lowest)?</h4>
                        <ul>
                            <li>Status printing is not time-critical</li>
                            <li>Can wait until other tasks finish</li>
                            <li>Button (5) > Serial (2) > Status (1)</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Understanding Mutex Operations -->
            <div class="section">
                <h2 class="section-title">üß† Understanding Mutex Operations</h2>

                <div class="info-box">
                    <h3>xSemaphoreTake() - "Lock the Mutex"</h3>
                    <div class="code-block">BaseType_t xSemaphoreTake(SemaphoreHandle_t mutex, TickType_t timeout);</div>
                    
                    <table>
                        <tr>
                            <th>Parameter</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>mutex</code></td>
                            <td>Handle to your mutex (e.g., <code>g_uartMutex</code>)</td>
                        </tr>
                        <tr>
                            <td><code>timeout</code></td>
                            <td>How long to wait if mutex already taken:<br>
                                <code>0</code> = Don't wait (return immediately)<br>
                                <code>portMAX_DELAY</code> = Wait forever<br>
                                <code>pdMS_TO_TICKS(1000)</code> = Wait 1 second</td>
                        </tr>
                        <tr>
                            <td><strong>Returns</strong></td>
                            <td><code>pdTRUE</code> if successful<br>
                                <code>pdFALSE</code> if timeout</td>
                        </tr>
                    </table>
                </div>

                <div class="info-box">
                    <h3>xSemaphoreGive() - "Unlock the Mutex"</h3>
                    <div class="code-block">BaseType_t xSemaphoreGive(SemaphoreHandle_t mutex);</div>
                    
                    <ul>
                        <li>Releases the mutex so other tasks can take it</li>
                        <li>MUST be called by the same task that took it</li>
                        <li>Always returns <code>pdTRUE</code> (or crashes if misused)</li>
                    </ul>
                </div>

                <div class="warning-box">
                    <h3>Common Mistakes to Avoid</h3>
                    
                    <p><strong>‚ùå WRONG: Taking mutex but never giving</strong></p>
                    <div class="code-block">xSemaphoreTake(g_uartMutex, portMAX_DELAY);
ESP_LOGI(<span class="string">"TAG"</span>, <span class="string">"Message"</span>);
<span class="comment">// Forgot xSemaphoreGive() - DEADLOCK!</span>
<span class="keyword">return</span>;  <span class="comment">// Other tasks blocked forever</span></div>

                    <p><strong>‚ùå WRONG: Holding mutex during delay</strong></p>
                    <div class="code-block">xSemaphoreTake(g_uartMutex, portMAX_DELAY);
ESP_LOGI(<span class="string">"TAG"</span>, <span class="string">"Message"</span>);
vTaskDelay(pdMS_TO_TICKS(1000));  <span class="comment">// DON'T DO THIS!</span>
xSemaphoreGive(g_uartMutex);
<span class="comment">// Other tasks blocked for entire second</span></div>

                    <p><strong>‚úÖ CORRECT: Minimal mutex hold time</strong></p>
                    <div class="code-block">xSemaphoreTake(g_uartMutex, portMAX_DELAY);
ESP_LOGI(<span class="string">"TAG"</span>, <span class="string">"Message"</span>);
xSemaphoreGive(g_uartMutex);  <span class="comment">// Release immediately</span>

vTaskDelay(pdMS_TO_TICKS(1000));  <span class="comment">// Delay AFTER giving mutex</span></div>
                </div>
            </div>

            <!-- Testing Guide -->
            <div class="section">
                <h2 class="section-title">üß™ Testing Your Implementation</h2>

                <div class="success-box">
                    <h3>Test 1: Status Command</h3>
                    <div class="code-block">// Type in serial monitor:
status

// Expected output:
SERIALTASK: Status report triggered
STATUS: ======== SYSTEM STATUS ========
STATUS: Current Speed: 400 ms
STATUS: Uptime: 123 sec
STATUS: Free Heap: 250000 bytes
STATUS: ==============================</div>
                </div>

                <div class="success-box">
                    <h3>Test 2: Periodic Status (Wait 5 Seconds)</h3>
                    <p>Status should print automatically every 5 seconds even without command.</p>
                </div>

                <div class="success-box">
                    <h3>Test 3: Concurrent Operations</h3>
                    <div class="code-block">// Rapidly press button while typing commands:
pattern 2
speed 600
status

// Output should be clean, no garbled text</div>
                </div>

                <div class="success-box">
                    <h3>Test 4: Status During Button Press</h3>
                    <p>Press button at same moment status prints - both should be readable, not mixed.</p>
                </div>
            </div>

            <!-- Implementation Checklist -->
            <div class="section">
                <h2 class="section-title">‚úÖ Implementation Checklist</h2>

                <ul class="checklist">
                    <li>Declare <code>g_uartMutex</code> global variable</li>
                    <li>Declare <code>g_statusTrigger</code> global variable</li>
                    <li>Create <code>g_uartMutex</code> with <code>xSemaphoreCreateMutex()</code></li>
                    <li>Create <code>g_statusTrigger</code> with <code>xSemaphoreCreateBinary()</code></li>
                    <li>Wrap all ESP_LOGI() in serialTask with mutex take/give</li>
                    <li>Implement <code>statusReporter()</code> task function</li>
                    <li>Make "status" command call <code>xSemaphoreGive(g_statusTrigger)</code></li>
                    <li>Create statusReporter task with priority 1</li>
                    <li>Test status command works</li>
                    <li>Test automatic 5-second status updates work</li>
                    <li>Test no garbled output during concurrent operations</li>
                </ul>
            </div>

            <!-- Key Concepts Summary -->
            <div class="section">
                <h2 class="section-title">üìö Key Concepts Summary</h2>

                <div class="info-box">
                    <h3>Mutex vs Binary Semaphore</h3>
                    <table>
                        <tr>
                            <th>Feature</th>
                            <th>Mutex</th>
                            <th>Binary Semaphore</th>
                        </tr>
                        <tr>
                            <td><strong>Purpose</strong></td>
                            <td>Protect shared resource</td>
                            <td>Signal between tasks</td>
                        </tr>
                        <tr>
                            <td><strong>Ownership</strong></td>
                            <td>Yes - same task must give</td>
                            <td>No - any task can give</td>
                        </tr>
                        <tr>
                            <td><strong>Priority Inheritance</strong></td>
                            <td>Yes (prevents priority inversion)</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td><strong>Use Case</strong></td>
                            <td>UART protection (mutual exclusion)</td>
                            <td>Status trigger (event notification)</td>
                        </tr>
                    </table>
                </div>

                <div class="success-box">
                    <h3>Best Practices Applied</h3>
                    <ul>
                        <li>‚úÖ <strong>Minimal lock time</strong> - Hold mutex only during critical section</li>
                        <li>‚úÖ <strong>Always pair</strong> - Every take has matching give</li>
                        <li>‚úÖ <strong>No delays</strong> - Never call vTaskDelay() while holding mutex</li>
                        <li>‚úÖ <strong>Error checking</strong> - Verify mutex creation succeeded</li>
                        <li>‚úÖ <strong>Priority inheritance</strong> - Mutex prevents priority inversion</li>
                        <li>‚úÖ <strong>Task coordination</strong> - Semaphore triggers immediate action</li>
                    </ul>
                </div>
            </div>

            <!-- Final Architecture -->
            <div class="section">
                <h2 class="section-title">üèóÔ∏è Final System Architecture</h2>

                <div class="mermaid-container">
                    <div class="mermaid">
                        graph TB
                            M[UART Mutex]
                            ST[Status Trigger]
                            PQ[Pattern Queue]
                            SQ[Speed Queue]
                            BT[Button Task Priority 5]
                            PS[Pattern Sequencer Priority 3]
                            SE[Serial Task Priority 2]
                            SR[Status Reporter Priority 1]
                            
                            BT -->|pattern cmd| PQ
                            SE -->|pattern cmd| PQ
                            SE -->|speed cmd| SQ
                            SE -->|trigger| ST
                            
                            PQ --> PS
                            SQ --> PS
                            ST --> SR
                            
                            BT -.uses.-> M
                            SE -.uses.-> M
                            PS -.uses.-> M
                            SR -.uses.-> M
                    </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });
    </script>
</body>
</html>